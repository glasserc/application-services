/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//! Our implementation of vector clocks. See the remerge RFC's appendix for an
//! overview of how these work if you're unfamiliar.

use rusqlite::types::{FromSql, FromSqlError, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
use std::collections::BTreeMap;
use sync_guid::Guid;

pub type Counter = u64;

/// A vector clock.
#[derive(Clone, Default, Debug, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub struct VClock(pub BTreeMap<Guid, Counter>);

/// Basically equivalent to Option<std::cmp::Ordering>, but more explicit about
/// what each value means. The variant documentation assumes this is generated by
/// something similar to `lhs.get_ordering(rhs)`.
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum ClockOrdering {
    /// The two clocks are equivalent.
    Equivalent,
    /// The `lhs` clock is an ancestor of the `rhs` clock.
    Ancestor,
    /// The `lhs` clock is a decendent of the `rhs` clock.
    Descendent,
    /// The two clocks are in conflict, and some other means of resolution must
    /// be used.
    Conflicting,
}

impl VClock {
    pub fn new(own_client_id: Guid, counter: Counter) -> Self {
        VClock(std::iter::once((own_client_id, counter)).collect())
    }

    /// Determine the ordering between `self` and `other`.
    pub fn get_ordering(&self, other: &VClock) -> ClockOrdering {
        let mut seen_gt = false;
        let mut seen_lt = false;

        let self_kvs = self.0.iter().map(|(id, &ctr)| (id, Some(ctr), None));
        let other_kvs = other.0.iter().map(|(id, &ctr)| (id, None, Some(ctr)));

        for (k, sv, ov) in self_kvs.chain(other_kvs) {
            let sv = sv.unwrap_or_else(|| self.get(k));
            let ov = ov.unwrap_or_else(|| other.get(k));
            if sv > ov {
                seen_gt = true;
            }
            if sv < ov {
                seen_lt = true;
            }
            if seen_gt && seen_lt {
                // No need to keep going once we've seen both.
                return ClockOrdering::Conflicting;
            }
        }
        match (seen_gt, seen_lt) {
            (false, false) => ClockOrdering::Equivalent,
            (true, false) => ClockOrdering::Ancestor,
            (false, true) => ClockOrdering::Descendent,
            (true, true) => ClockOrdering::Conflicting,
        }
    }

    pub fn are_equivalent(&self, o: &VClock) -> bool {
        self.get_ordering(o) == ClockOrdering::Equivalent
    }

    pub fn is_ancestor_of(&self, o: &VClock) -> bool {
        self.get_ordering(o) == ClockOrdering::Ancestor
    }

    pub fn is_descendent_of(&self, o: &VClock) -> bool {
        self.get_ordering(o) == ClockOrdering::Descendent
    }

    pub fn are_conflicting(&self, o: &VClock) -> bool {
        self.get_ordering(o) == ClockOrdering::Conflicting
    }

    /// Get the clock's value for client_id, or 0 if it hasn't seen it.
    pub fn get(&self, client_id: &Guid) -> Counter {
        self.0.get(&client_id).copied().unwrap_or_default()
    }

    /// Add one to the clock's value for client_id
    pub fn increment(&mut self, client_id: Guid) {
        *self.0.entry(client_id).or_default() += 1
    }

    /// Assign `value` for client_id directly. Usually you want `apply` instead
    pub fn set_directly(&mut self, client_id: Guid, value: Counter) {
        if value == 0 {
            self.0.remove(&client_id);
        } else {
            self.0.insert(client_id, value);
        }
    }

    /// If `value` is greater than the current value for client_id store that
    /// instead. Otherwise, do nothing.
    ///
    /// Notes that this clock has seen the `value`th event of `client_id`.
    pub fn apply(&mut self, client_id: Guid, value: Counter) {
        if value == 0 {
            // Avoid inserting 0 if we can help it.
            return;
        }
        let old_value = self.0.entry(client_id).or_default();
        if *old_value < value {
            *old_value = value;
        }
    }

    pub fn apply_all(&mut self, o: &VClock) {
        for (id, ctr) in &o.0 {
            self.apply(id.clone(), *ctr)
        }
    }

    pub fn merge(&self, o: &VClock) -> Self {
        let mut res = self.clone();
        res.apply_all(o);
        res
    }
}

impl PartialOrd for VClock {
    fn partial_cmp(&self, other: &VClock) -> Option<std::cmp::Ordering> {
        match self.get_ordering(other) {
            ClockOrdering::Equivalent => Some(std::cmp::Ordering::Equal),
            ClockOrdering::Ancestor => Some(std::cmp::Ordering::Greater),
            ClockOrdering::Descendent => Some(std::cmp::Ordering::Less),
            ClockOrdering::Conflicting => None,
        }
    }
}

impl ToSql for VClock {
    fn to_sql(&self) -> rusqlite::Result<ToSqlOutput> {
        // serde_json::to_string only fails for types which can't be encoded as
        // JSON (recursive graphs, maps with non-string keys, etc) so unwrap
        // here is fine.
        Ok(ToSqlOutput::from(serde_json::to_string(self).unwrap()))
    }
}

impl FromSql for VClock {
    fn column_result(value: ValueRef) -> FromSqlResult<Self> {
        value.as_str().and_then(|s| {
            serde_json::from_str(s).map_err(|e| {
                log::error!("Failed to read vector clock from SQL");
                log::debug!("  error: {:?}", e);
                FromSqlError::Other(Box::new(e))
            })
        })
    }
}
